------------------------------------------------------------------------
-- FILE: init.lua
------------------------------------------------------------------------

  -- [Stopped Working]
  -- prefix:bind({}, 'h', hs.window.focusWindowWest)
  -- prefix:bind({}, 'j', hs.window.focusWindowSouth)
  -- prefix:bind({}, 'k', hs.window.focusWindowNorth)
  -- prefix:bind({}, 'l', hs.window.focusWindowEast)

  -- prefix:bind({}, '\\', hs.reload)

  -- function sendKeyStroke(mods, key)
  --   return function()
  --     hs.eventtap.keyStroke(mods, key)
  --   end
  -- end
  -- hs.hotkey.bind({'ctrl', 'shift'}, '[', sendKeyStroke({'cmd', 'shift'}, '['))
  -- hs.hotkey.bind({'ctrl', 'shift'}, ']', sendKeyStroke({'cmd', 'shift'}, ']'))

------------------------------------------------------------------------
--                              CHUNKWM                               --
------------------------------------------------------------------------

-- hyper_mod = {'ctrl', 'alt', 'cmd'}
--
-- function cwmap(mods, key, args)
--   hs.hotkey.bind(mods, key, function()
--     out, st, ty, rc = hs.execute('/usr/local/bin/chunkc ' .. args)
--     print(st, out, args)
--   end)
-- end
--
-- cwmap(hyper_mod , 'h'     , 'tiling::window --focus west')
-- cwmap(hyper_mod , 'left'  , 'tiling::window --focus west')
--
-- cwmap(hyper_mod , 'j'     , 'tiling::window --focus south')
-- cwmap(hyper_mod , 'down'  , 'tiling::window --focus south')
--
-- cwmap(hyper_mod , 'k'     , 'tiling::window --focus north')
-- cwmap(hyper_mod , 'up'    , 'tiling::window --focus north')
--
-- cwmap(hyper_mod , 'l'     , 'tiling::window --focus east')
-- cwmap(hyper_mod , 'right' , 'tiling::window --focus east')
--
-- cwmap(hyper_mod , 'p' , 'tiling::window --toggle parent')
-- cwmap(hyper_mod , 'f' , 'tiling::window --toggle fullscreen')
--
-- cwmap(hyper_mod , 'm' , 'set bsp_split_mode vertical')
-- cwmap(hyper_mod , 'n' , 'set bsp_split_mode horizontal')
--
--
-- cwmap({'alt'}, 'a', 'tiling::desktop --layout bsp')
-- cwmap({'alt'}, 's', 'tiling::desktop --layout monocle')
-- cwmap({'alt'}, 'd', 'tiling::desktop --layout float')
--
-- cwmap({'alt'}, 'q', 'tiling::desktop --toggle offset')
--
-- for i=1,9 do  -- -- -- -- -- -- -- -- -- --
------------------------------------------------------------------------
--   cwmap({'shift', 'alt'}, is, 'tiling::window --send-to-desktop ' .. is)
-- end
--
-- cwmap({'shift', 'alt'}, 'space', 'tiling::window --toggle float')


------------------------------------------------------------------------
--                               Unused                               --
------------------------------------------------------------------------

-- function langSwitch(code) -- {{{
--   return function()
--     if code == "EN" then
--       hs.keycodes.setLayout("U.S.")
--     elseif code == "RU" then
--       hs.keycodes.setLayout("Russian - Phonetic")
--     end
--   end
-- end -- }}}


-- function windowYank() -- {{{
--   local w = hs.window.focusedWindow()
--
--   windowYankBuffer = {}
--   windowYankBuffer['win_id'] = w:id()
--
--   print(windowYankBuffer['win_id'])
-- end -- }}}
-- function windowPut() -- {{{
--   if not(windowYankBuffer) then
--     print("Window Buffer not set")
--     return 
--   end
--   local win_id = windowYankBuffer['win_id']
--   print(windowYankBuffer['win_id'])
--
--   local w = hs.window.find(win_id)
--   if not(w) then 
--     print("No window with id")
--     return
--   end
--
--   local cur_screen = hs.screen.mainScreen()
--   local scs = hs.screen.allScreens()
--
--   tmgrid.showGrid({'.'}, scs, function(rect, hint) 
--     local screen_num = tonumber(string.sub(hint, 0, 1))
--     w:moveToScreen(scs[screen_num])
--   end)
-- end -- }}}

-- bindGrid("g", {
--   "aab",
--   "aab",
--   "aac"
-- })

-- hs.hotkey.bind({'ctrl', 'alt'}, "=", function() 
--   local screens = hs.screen.allScreens()
--
--   local rotations = {
--     [722475280] = 0,
--     [722496271] = 0,
--   }
--
--   for i, screen  in ipairs(screens) do
--     local screen_id = screen:id()
--     if not(rotations[screen_id] == nil) then
--       screen:rotate(rotations[screen_id])
--     end
--   end
--
--   for i, screen  in ipairs(hs.screen.allScreens()) do
--     print("Name:" .. screen:name())
--     print("ID:" .. tostring(screen:id()))
--     print("Rotation:" .. tostring(screen:rotate()))
--     print("-------------")
--   end
-- end)

-- qa.setMenu({
--   qa.mkmenu("Languages", {
--     qa.mkmenu("English", langSwitch("EN")),
--     qa.mkmenu("Russian", langSwitch("RU")),
--   }),
--   qa.mkmenu("-"),
--   qa.mkmenu("Exit")
-- }).update()
--
-- prefix.bind({}, 'q', function() 
--   local p = hs.screen.mainScreen():frame().center
--   qa.bar:popupMenu(p)
-- end)

-- qa = {}
-- qa.menu = {
--   { title = "Work Utils", 
--     menu = {
--       { title = "Mail GenStatus (This Week)", fn = function () workUtil_GenStatus(1) end },
--       { title = "Mail GenStatus (Past Week)", fn = function () workUtil_GenStatus(0) end }
--     }
--   },
-- }
--
-- qa.bar = hs.menubar.new()
-- qa.bar:setTitle("QAct")
-- qa.bar:setMenu(qa.menu)
--
-- function workUtil_GenStatus(thisWeek)
--   manager = "dsawyer@uber.com"
--   utils.composeMail(manager, "Hello", "<b>Focus:</b> lalalal \n")
-- end
--
--

-- Welp that did not work out =[
-- Focus Follows mouse is incredibly hard to implement
--
-- local mouseMoved = false
-- local activeWindow = nil
--
-- hs.eventtap.new({hs.eventtap.event.types['mouseMoved']}, function(e)
--   mouseMoved = true
-- end):start()
--
-- hs.timer.doEvery(0.1, function() 
--   if mouseMoved then
--     local my_pos = hs.geometry.new(hs.mouse.getAbsolutePosition())
--     local my_screen = hs.mouse.getCurrentScreen()
--
--     window = hs.fnutils.find(hs.window.orderedWindows(), function(w)
--       return my_screen == w:screen() and my_pos:inside(w:frame())
--     end)
--     print(hs.inspect(window, 2), mouseMoved)
--     -- mouseMoved = false
--   end
-- end)

-- keyTimes = {}
--
-- hs.eventtap.new({hs.eventtap.event.types['keyDown'], hs.eventtap.event.types['keyUp']}, function(e)
-- if not(e == nil) then
--   local etype = e:getType()
--   local ekey = e:getKeyCode()
--   local etime = hs.timer.absoluteTime() 
--   
--   if etype == hs.eventtap.event.types['keyDown'] then
--     if keyTimes[ekey] ~= nil then
--       keyTimes[ekey] = etime
--     end
--   elseif etype == hs.eventtap.event.types['keyUp'] then
--     local etimelapse = keyTimes[ekey]
--
--     if not(etimelaps == nil) then
--       print(etime - keyTimes[ekey])
--       keyTimes[ekey] = nil
--     end
--   end
-- end
--
-- return false, e
-- end):start()
--
-- local lastEvent = nil
--
-- local timer_conf = {}
-- function config_timer(_name, _seconds)
--   if not(timer_conf[_name] == nil) then
--     timer_conf[_name]:stop()
--   end
--
--   if _seconds > 0 then
--     timer_conf[_name] = hs.timer.doAfter(_seconds, function()
--       print("Tiiiiiimmmmmmeeeerrrrr!", _name)
--     end)
--   else
--     timer_conf[_name] = nil
--   end
-- end
--
-- function show_timer(_name, _seconds)
--   if not(timer_conf[_name] == nil) then
--     return timer_conf[_name]:nextTrigger()
--   end
--   return nil
-- end


