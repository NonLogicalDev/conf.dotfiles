#!/bin/zsh
SCRIPT_PATH=$0

help() {
  cat ${SCRIPT_PATH} | grep "^ *#"":" | sed 's/^ *#://'
}

_die() {
  if [[ -n $1 ]]; then
    echo "ERROR: $1" >&2
    echo
  fi

  if [[ -n $__DOC__ ]]; then
    echo "$__DOC__" >&2
  fi

  exit 128
}

#######################################################################
#                          Stacked Git Utils                          #
#######################################################################

stg-apply-set() {
  #: stg-apply-set [GREP_EXPR]
  #:   interactively apply patches on the stack that match $GREP_EXPR
  #:

  local ALL="# ALL #"
  local ERR="# ERR #"

  local TOAPPLY=$(stg ls -a | grep "^$1")
  local SELECT=$(set -e -o pipefail;
    ( ( echo "$ALL" && echo "$TOAPPLY" ) | fzf --multi +s ) || echo "$ERR"
  )

  if [[ $(echo $SELECT | head -n 1) == $ERR ]]; then
    echo "Aborted" >&2
    exit 120
  fi
  if [[ $(echo $SELECT | head -n 1) != $ALL ]]; then
    TOAPPLY=$SELECT
  fi

  echo "APPLYING:"
  echo "--------"
  echo "$TOAPPLY"
  echo "--------"

  stg pop -a
  (set -e -o pipefail;
    echo "$TOAPPLY" | xargs -p stg push
  )
  return $?
}

stg-info() {
  #: stg-info
  #:   print status and expanded information about the current stack.
  #:

  echo "## Status:"
  git -c color.status=always status -s \
    | sed 's:^:    :'

  echo

  echo "## Stack:"
  stg-pretty-series -e \
    | sed 's:^:    :'
}


stg-overview() {
  #: stg-overview
  #:   prints an overview of all currently active stg branches.
  #:   (i.e. prints out the current stack state)
  #:

  stg-branches | xargs -I {} sh -c 'echo "::::: {}" && stg series -b {} && echo'
}

stg-list-patches() {
  #: stg-list-patches [<stg series options>]
  #:   prints undecorated list of patches
  #:

  stg series --noprefix --no-description "$@"
}

stg-stack-files() {
  #: stg-stack-files
  #:   show all files the patches in the stack modify
  #:

  git diff $(stg id $(stg series --noprefix | head -n 1)).. --name-status | cat
}

stg-series-pretty() {
  #: stg-series-pretty [-f] [-e] [-n] [<stg series options>]
  #:   prints expanded information about the patches in the current stack
  #:
  #:   -n | --notes : show notes associated with git commit
  #:   -e | --extra : show git sha, notes
  #:   -f | --full  : show git sha, notes, commit msg & files affected
  #:

  local ARGS=()

  local _full=0
  local _extra=0
  local _notes=0
  local _help=0
  local _filter_set=0
  while [[ $# -gt 0 ]]; do
    if [[ $1 == (--full|-f) ]]; then
      _full=1
      shift
    elif [[ $1 == (--extra|-e) ]]; then
      _extra=1
      shift
    elif [[ $1 == (--notes|-n) ]]; then
      _notes=1
      shift
    elif [[ $1 == (--help|-h) ]]; then
      _help=1
      shift
    elif [[ $1 == (-a|-A|-U|-H) ]]; then
      _filter_set=1

      ARGS+=($1)
      shift
    else
      ARGS+=($1)
      shift
    fi
  done

  if [[ $_filter_set -eq 0 ]]; then
    ARGS=(-A)
  fi

  if [[ _help -eq 1 ]]; then
    stg series -h
    exit $?
  fi

  while read line; do
    # ZSH-NOTE: ( ${(@f)$( command )} ) splits command output by newline, returns array. (zsh)
    stg_fields=( "${(@f)$(
      echo $line | awk '{
        # stg_patch_status:
        print $1;

        # stg_patch_name_col:
        print substr($0, index($0,$2),index($0,$3) - index($0,$2));

        # stg_patch_description_col:
        print substr($0,index($0,$4));

        # stg_patch_name:
        print $2
      }'
    )}" )

    stg_patch_status=${stg_fields[1]}
    stg_patch_name_col=${stg_fields[2]}
    stg_patch_description_col=${stg_fields[3]}
    stg_patch_name=${stg_fields[4]}

    git_sha=$(stg id "$stg_patch_name" | xargs git rev-parse --short)

    COLOR=1
    if [[ $stg_patch_status == "+" ]]; then
      COLOR=2
    elif [[ $stg_patch_status == ">" ]]; then
      COLOR=3
    fi

    printf "%s$stg_patch_status $stg_patch_name_col%s # $stg_patch_description_col\n" $(tput setaf $COLOR) $(tput sgr0)

    details=$(
      if [[ $_full -eq 1 || $_extra -eq 1 ]]; then
        printf "%sgit-sha%s $git_sha\n\n" $(tput setaf 4) $(tput sgr0)
      fi

      if [[ $_full -eq 1 ]]; then
        git_commit_msg=$(
          git show -s --format=%b "$git_sha" \
            | fold -w 80 -s \
            | perl -0pe 's:[\n\s]+$:\n:'
        )

        commit_prefix="$(tput setaf 1)#$(tput sgr0)"
        if [[ -n $git_commit_msg ]]; then
          echo "$git_commit_msg" \
            | awk -v prefix="$commit_prefix" '{print prefix " " $0}'
        else
          echo "$commit_prefix [ No Commit Summary ]"
        fi
        echo
      fi

      if [[ $_full -eq 1 || $_notes -eq 1 || $_extra -eq 1 ]]; then
        git_notes=$(
          git notes show "$git_sha" 2>/dev/null \
            | perl -pe 's:(arc-revision|depends-on) :$1 D:' \
        )
        if [[ -n $git_notes ]]; then
          echo "$git_notes" \
            | perl -pe "s:^\\s*([^\s]+)\\s+(.*):$(tput setaf 4)\\1$(tput sgr0) \\2:" \
            | column -tx -s " "
          echo
        fi
      fi

      if [[ $_full -eq 1 ]]; then
        git show --name-status --format= "$git_sha" \
          | perl -pe "s:^(\\s*\\w+)(.*):$(tput setaf 2)\\1$(tput setaf 4)\\2$(tput sgr0):"
      fi
    )

    if [[ -n "$details" ]]; then
      result=$(
          printf "%s" "$details"
          printf "\n \n"
      )
      echo "$result" | sed 's:^:    :'
    fi
  done << EOF
$(stg series -d "${ARGS[@]}")
EOF
}

stg-bottom() {
  #: stg-bottom
  #:   get the sha of the first applied commit in the stack
  #:

  stg-list-patches -A | head -n 1 | xargs stg id
}

stg-top() {
  #: stg-top
  #:   get the sha of the last applied commit in the stack
  #:

  stg-list-patches -A | tail -n 1 | xargs stg id
}


stg-ctx() {
  #: stg-ctx
  #:   interactively switch stacked git branch
  #:

  stg-branches | fzf "$@" --preview 'stg series -b {}' | xargs stg branch --switch
}

stg-branches() {
  #: stg-ctx
  #:   list all stacked git enabled branches
  #:

  git branch | cut -c 3- | grep .stgit | sed 's:.stgit::'
}

stg-rstash() {
  #: stg-rstash
  #:   stash/publish the current patch to the remote
  #:

  # Check that Stg is enabled
  stg top 2>/dev/null >/dev/null
  if [[ $? -ne 0 ]]; then
    _die "stg-rstash: ${GIT_BRANCH}: branch not initialized"
  fi

  STG_PATCH_NAME=$(stg top)

  git-rstash "$@" -- "HEAD:${STG_PATCH_NAME}"
}

stg-publish() {
  #: stg-publish <REMOTE> [REMOTE_BRANCH]
  #:   publish the current stack to the remote
  #:

  local REMOTE_NAME="$1"
  local REMOTE_BRANCH="$2"
  shift 2

  # Check that Stg is enabled
  stg top 2>/dev/null >/dev/null
  if [[ $? -ne 0 ]]; then
    _die "stg-publish: ${GIT_BRANCH}: branch not initialized"
  fi

  local GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
  local GIT_BRANCH_STG="${GIT_BRANCH}.stgit"

  if [[ -z $REMOTE_BRANCH ]]; then
    REMOTE_BRANCH="$GIT_BRANCH"
  fi
  local REMOTE_BRANCH_STG="${REMOTE_BRANCH}.stgit"

  if [[ -z $(git branch --list ${GIT_BRANCH_STG}) ]]; then
    _die "stg-rstash: ${GIT_BRANCH_STG}: does not exist"
  fi

  git push "$REMOTE_NAME" \
      "${GIT_BRANCH}:${REMOTE_BRANCH}" \
      "${GIT_BRANCH_STG}:${REMOTE_BRANCH_STG}"
}

stg-heads() {
  #: stg-heads [-n]
  #:   print out HEAD offset references for all applied patches
  #:
  #:   (-n): print references in one line, one per line otherwise
  #:

  local REFS=()
  for i in $(seq 0 $(stg series -A |wc -l)); do
    REFS+=("HEAD~$i")
  done
  if [[ $1 == "-n" ]]; then
    echo "${REFS[@]}"
  else
    printf "%s\n" "${REFS[@]}"
  fi
}

#######################################################################
#                            Git Utilites                             #
#######################################################################

git-quick-log() {
  git log -n 3 --format="%h %al (%ar)%n  %s" "$@"
}

git-info() {
  GIT_UPSTREAM=$(git rev-parse --abbrev-ref HEAD@{upstream} 2>/dev/null)

  if [[ -z "$GIT_UPSTREAM" ]]; then
    git lg -n 5
  else
    GIT_MERGEPOINT=$(git merge-base --fork-point $GIT_UPSTREAM)
    git lg ${GIT_MERGEPOINT}^1..HEAD
  fi
}

git-ctx() {
  #: git-ctx
  #:   interactively switch to a different branch using FZF with log preview
  #:

  git-branch-log 100 \
  | fzf +s "$@" --preview='git-utils git-quick-log -n 5 {}' --height "100%" --preview-window="right:60%" \
  | xargs git switch
}

git-branch-log() {
  #: git-branch-log
  #:   show branch history, i.e. show branches in the order of last visited
  #:

  local __max_num=${1:-20}

  git-branch-history-list \
    | awk '{print $1}' \
    | awk '!x[$0]++' \
    | head -n ${__max_num}
}

git-branch-history() {
  #: git-branch-history
  #:   show branch switching history, i.e. show moving between branches in the order of last visited
  #:

  local __max_num=${1:-20}

  git-branch-history-list \
    | awk '{print $2 "%%" "<-" "%%" $1}' \
    | column -tx -s "%%" \
    | head -n ${__max_num}
}


git-branch-history-list() {
  git reflog \
    | grep --line-buffered 'checkout: moving from' \
    | perl -pe 's/.*moving from (.+) to (.+)/$1\t$2/'
}

git-browse() {
  local __url=$(git-browse-url "$@")
  if [[ -n $__url ]]; then
    ( set -x; open $__url; )
  else
    _die "git-browse not configured"
  fi
}

git-browse-url() {
  # browse.url-file [local]
  # browse.url-dir [local]
  #
  # browse.service [local]
  # browse.service-default [global]
  #
  # browse.sourcegraph.domain [global]
  # browse.sourcegraph.repo [local]
  #
  # browse.github.domain [global]
  # browse.github.repo [local]

  local __file_path=""
  if [[ -n $1 ]]; then
    __file_path=$(git ls-files --full-name "$1")
  fi
  local __line=$2

  local __browse_url_file_expr=""
  local __browse_url_dir_expr=""

  local __browse_service=$(git config browse.service)
  local __browse_service_default=$(git config browse.service-default)
  local __origin_url=$(git remote get-url origin)

  if [[ -z $__browse_service ]]; then
    if [[ $__origin_url =~ ".*github.com.*" ]]; then
      __browse_service="github"
    else
      __browse_service="$__browse_service_default"
    fi
  fi

  case $__browse_service in
    "sourcegraph")
      local __sg_domain=$(git config browse.sourcegraph.domain) # https://sourcegraph.domain.com
      local __sg_repo=$(git config browse.sourcegraph.repo)     # repo/path

      if [[ -z $__sg_domain ]]; then
        __sg_domain="https://sourcegraph.com"
      fi
      if [[ -z $__sg_repo ]]; then
        __sg_repo=$(echo $__origin_url | perl -pe 's/^(.+@)//,s/:/\//')
      fi

      __browse_url_file_expr='${__sg_domain}/${__sg_repo}/-/blob/${__file_path}#L${__line}'
      __browse_url_dir_expr='${__sg_domain}/${__sg_repo}/-/blob/${__file_path}'
      ;;

    "github")
      local __gh_domain=$(git config browse.github.domain) # https://sourcegraph.domain.com
      local __gh_repo=$(git config browse.github.repo)     # repo/path

      if [[ -z $__sg_domain ]]; then
        __gh_domain="https://github.com"
      fi
      if [[ -z $__sg_repo ]]; then
        __gh_repo=$(echo $__origin_url  | perl -pe 's/^(.+@)(github.com:)?//,s/\.git$//,s/:/\//')
      fi

      __browse_url_file_expr='${__gh_domain}/${__gh_repo}/blob/HEAD/${__file_path}#L${__line}'
      __browse_url_dir_expr='${__gh_domain}/${__gh_repo}/tree/HEAD/${__file_path}'
      ;;
  esac

  local __u_browse_url_file_expr=$(git config browse.url-file)
  if [[ -n $__u_browse_url_file_expr ]]; then
    __browse_url_file_expr=$__u_browse_url_file_expr
  fi

  local __u_browse_url_dir_expr=$(git config browse.url-dir)
  if [[ -n $__u_browse_url_dir_expr ]]; then
    __browse_url_dir_expr=$__u_browse_dir_file_expr
  fi

  if [[ -d "$1" ]]; then
    eval echo ${__browse_url_dir_expr}
  else
    eval echo ${__browse_url_file_expr}
  fi
}

git-rstash() {
  PROG="$(basename $0)"

  local REF_FOLDER=$(git config --get rstash.ref)
  if [[ -z $REF_FOLDER ]]; then
    REF_FOLDER=$(whoami)
  fi

  local REF_PREFIX=$(git config --get rstash.prefix)
  if [[ -z $REF_PREFIX ]]; then
    REF_PREFIX=refs/heads
  fi

  local REF_REMOTE=$(git config --get rstash.remote)
  if [[ -z $REF_REMOTE ]]; then
    REF_REMOTE=origin
  fi

  local REMOTE_PREFIX="${REF_PREFIX}/${REF_FOLDER}"

  local __DOC__=$(
    echo "INFO:"
    echo "  A utility for stashing branches to a remote."
    echo "  It stashes given commits under: [REMOTE]/${REMOTE_PREFIX}"
    echo "Usage:"
    echo "  $PROG REMOTE [SPEC...]"
    echo "Parameters:"
    echo "  - REMOTE: git remote to use as a remote stash"
    echo "  - SPEC: git refspec, ex: HEAD:<remote_name>"
    echo "Variations:"
    echo "  -- [SPEC...]          : to use default remote"
    echo "Settings:"
    echo "  --set-ref <ref>       : to set which remote prefix to use"
    echo "  --set-remote <remote> : to set which remote to use by default"
    echo "  --get                 : to get current settings"
  )

  for i in "$@"; do
    case $i; in
      --set-ref)
        shift 1
        git config rstash.ref $1
        break
        ;;

      --set-remote)
        shift 1
        git config rstash.remote $1
        break
        ;;

      --get)
        echo "rstash.ref     : $REF_FOLDER"
        echo "rstash.prefix  : $REF_PREFIX"
        echo "rstash.remote  : $REF_REMOTE"
        echo
        echo "@remote-prefix : $REMOTE_PREFIX"
        break
        ;;

      --)
        shift 1
        __git_rstash_internal $REF_REMOTE "$@"
        break
        ;;

      *)
        __git_rstash_internal "$@"
        break
        ;;
    esac
  done
}

__git_rstash_internal() {
  # ENV: REMOTE_PREFIX

  local REMOTE="$1"
  shift

  local DRY_RUN=

  [[ -z $REMOTE ]] && _die "Remote not specified."
  if [[ $REMOTE == "-d" ]]; then
    DRY_RUN=true
  fi

  if [[ -z $DRY_RUN ]] && ! ( git remote | grep -e "$REMOTE" -q ); then
    _die "Remote $REMOTE not found."
  fi

  [[ -z "$@" ]] && _die "Must provide at least one spec."

  local GIT_ARGS=()
  for arg in "$@"; do
    local A=(${(s_:_)arg})

    local L=${A[1]};
    local R=${(j_:_)${A[@]:1}}

    if [[ -z $R ]]; then
      if [[ $L == "HEAD" ]]; then
        R=$(git rev-parse --abbrev-ref HEAD)
      else
        R=$L
      fi
    fi

    GIT_ARGS+="${L}:${REMOTE_PREFIX}/${R}"
  done

  if [[ -z $DRY_RUN ]]; then
    ( set -x; git push -f $REMOTE $GIT_ARGS )
  else
    ( set -x; : git push -f "[remote]" $GIT_ARGS )
  fi
}


#######################################################################
#                           FARC Extensions                           #
#######################################################################

farc-quick() {
  local ARGS=()
  while [[ $# -gt 0 ]]; do
    ARGS+=($1)
    shift
  done
  farc "${ARGS[@]}"
}

stg-farc() {
  stg-refs | farc-bulk --stdin --fzf $@
}

farc-bulk() {
  local FARC_CMD=$1; shift
  local REFS=()
  local ARGS=()

  local _fzf=0
  local _rest=0
  local _stdin=0
  while [[ $# -gt 0 ]]; do
    if [[ $1 == '--' ]]; then
      _rest=1
      shift
    elif [[ $1 == '--fzf' ]]; then
      _fzf=1
      shift
    elif [[ $1 == '--stdin' ]]; then
      _stdin=1
      shift
    elif [[ _rest -eq 1 ]]; then
      REFS+=($1)
      shift
    else
      ARGS+=($1)
      shift
    fi
  done

  if [[ _stdin -eq 1 ]]; then
    while IFS="" read -r REF || [ -n "$REF" ]; do
      REFS+=($REF)
    done
  fi

  if [[ ${#REFS[@]} -lt 1 ]]; then
    REFS+=(HEAD)
  fi

  local RESULTS=$(printf "%s\n" "${REFS[@]}")
  if [[ _fzf -eq 1 ]]; then
    RESULTS=$(echo "$RESULTS" | fzf -m --preview="git show --oneline --name-status {}")
  fi

  echo -n "$RESULTS" | xargs -p -I %REF% echo farc "$FARC_CMD" "%REF%" "${ARGS[@]}"
}

#######################################################################

if [[ "$1" == (-h|--help|-?) ]]; then
  help
  exit 125
fi
"$@"
