#!/bin/zsh

# DEPENDENCIES: git-rstash

SCRIPT_PATH=$0

help() {
  cat ${SCRIPT_PATH} | grep "^ *#:" | sed 's/^ *#: *//g'
}

#######################################################################
#                          Stacked Git Utils                          #
#######################################################################


stg-info() {
  #: stg-info - prints status and expanded information about the current stack.

  echo "## Status:"
  stg status \
    | sed 's:^:    :'

  echo

  echo "## Stack:"
  stg lg \
    | sed 's:^:    :'
}

stg-showstat() {
  #: stg-showstat - prints the modified files 
  
  stg show -O "--name-status" "$@"
}

stg-lg() {
  #: stg-lg - prints expanded information about the current stack.

  while read line; do
    echo "$line"

    git_sha=$(echo $line | awk '{print $2}' | xargs stg id | xargs git rev-parse --short)

    git_notes=$(
      echo "git-sha $git_sha"
      echo

      git notes show "$git_sha" 2>/dev/null \
      | perl -pe 's:(arc-revision|depends-on) :$1 D:' \
      | column -tx -s " "
    )

    result=$(
      echo "$git_notes"
      echo ""
      git show --name-status --format= "$git_sha"
    )

    echo "$result" | sed 's:^:    :'
    echo
  done << EOF
$(stg series -d "$@")
EOF
}

stg-bottom() {
  #: stg-bottom - get the sha of the first commit in the stack.
  stg ls -A | head -n 1 | xargs stg id
}


stg-gn() {
  #: stg-gn - go to next patch in the stack.

  stg goto "$@" "$(stg next)"
}

stg-gp() {
  #: stg-gp - go to previous patch in the stack.

  stg goto "$@" "$(stg prev)"
}

stg-ctx() {
  #: stg-ctx - interactively switch stacked git branch.

  stg-branches | fzf "$@" | xargs git switch
}

stg-branches() {
  git branch | cut -c 3- | grep .stgit | sed s:.stgit::
}

stg-rstash() {
  #: stg-rstash - interactively switch stacked git branch.

  git rstash "$@" -- "HEAD:$(stg top)";
}

stg-refs() {
  local REFS=()
  for i in $(seq 0 $(stg series |wc -l)); do
    REFS+=("HEAD~$i")
  done
  if [[ $1 == "-n" ]]; then
    echo "${REFS[@]}"
  else
    printf "%s\n" "${REFS[@]}"
  fi
}

stg-overview() {
  stg-branches | xargs -I {} sh -c 'echo "::::: {}" && stg series -b {} && echo'
}

#######################################################################
#                            Git Utilites                             #
#######################################################################

git-ctx() {
  git-branch-log 100 \
  | grep -v ".stgit" \
  | fzf +s "$@" --preview='git-utils git-quick-log -n 5 {}' --height "100%" --preview-window="right:60%" \
  | xargs git switch
}

git-branch-history() {
  local __max_num=${1:-20}

  git-branch-history-list ${__max_num} \
    | awk '{print $2 "%%" "<-" "%%" $1}' \
    | column -tx -s "%%" \
    | less
}

git-branch-log() {
  local __max_num=${1:-20}

  git-branch-history-list ${__max_num} \
    | awk '{print $2}' \
    | awk '!x[$0]++'
}

git-branch-history-list() {
  local __max_num=$1

  git reflog \
    | grep --line-buffered 'checkout: moving from' \
    | perl -pe 's/.*moving from (.+) to (.+)/$1 $2/'  \
    | head -n ${__max_num}
}

git-quick-log() {
  git log -n 3 --format="%h %al (%ar)%n  %s" "$@"
}

#######################################################################
#                           FARC Extensions                           #
#######################################################################

farc-quick() {
  local ARGS=()
  while [[ $# -gt 0 ]]; do 
    ARGS+=($1)
    shift
  done
  farc "${ARGS[@]}"
}

stg-farc() {
  stg-refs | farc-bulk --stdin --fzf $@ 
}

farc-bulk() {
  local FARC_CMD=$1; shift
  local REFS=()
  local ARGS=()

  local _fzf=0
  local _rest=0
  local _stdin=0
  while [[ $# -gt 0 ]]; do 
    if [[ $1 == '--' ]]; then
      _rest=1
      shift
    elif [[ $1 == '--fzf' ]]; then
      _fzf=1
      shift
    elif [[ $1 == '--stdin' ]]; then
      _stdin=1
      shift
    elif [[ _rest -eq 1 ]]; then
      REFS+=($1)
      shift
    else
      ARGS+=($1)
      shift
    fi
  done

  if [[ _stdin -eq 1 ]]; then
    while IFS="" read -r REF || [ -n "$REF" ]; do
      REFS+=($REF)
    done 
  fi
  
  if [[ ${#REFS[@]} -lt 1 ]]; then
    REFS+=(HEAD)
  fi

  local RESULTS=$(printf "%s\n" "${REFS[@]}")
  if [[ _fzf -eq 1 ]]; then
    RESULTS=$(echo "$RESULTS" | fzf -m --preview="git show --oneline --name-status {}")
  fi

  echo -n "$RESULTS" | xargs -p -I %REF% echo farc "$FARC_CMD" "%REF%" "${ARGS[@]}"
}

#######################################################################

"$@"
