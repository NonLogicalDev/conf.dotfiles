#!/bin/zsh
SCRIPT_PATH=$0

unset GIT_DIR

__help() {
  cat ${SCRIPT_PATH} | grep "^ *#"":" | sed 's/^ *#://'
}

__die() {
  if [[ -n $1 ]]; then
    echo "ERROR: $1" >&2
    echo
  fi

  if [[ -n $__DOC__ ]]; then
    echo "$__DOC__" >&2
  elif [[ $2 == "" ]]; then
    exit 128
  fi
  exit $2
}

#######################################################################
#                          Stacked Git Utils                          #
#######################################################################

spill-interactive() { 
  stg files|gum filter --no-limit --height=20|cut -f 2|(cd $(git root); xargs stg spill --)
}

new-patch-from-index() {
  #: new-patch-from-index [PATCH_NAME] -m "message"
  #:   creates a new patch from current index
  #:

  stg new "$@" && checked-refresh-index
}

__check-header() {
  local TARGET_PATCH=$1

  local GIT_HEAD=$(git rev-parse --short $(stg id $TARGET_PATCH))
  local STG_STACK_REF=$(stg log -n 1 | head -n 1 | awk '{print $1}')

  echo ">> Applying diff to patch: $TARGET_PATCH"
  echo "   (sha:$GIT_HEAD) (stg-stack:$STG_STACK_REF)"
  git show -s "$GIT_HEAD" --format=%s | sed 's/^/   /'

  echo
  stg files "$TARGET_PATCH" 
}

check-index() { 
  __assert_stg_enabled "check-index"

  TARGET_PATCH=$(stg top)
  if [[ -n $1 ]]; then
    TARGET_PATCH=$1
  fi

  __check-header "$TARGET_PATCH"
  echo

  echo ">> Diff:"
  echo
  git --no-pager diff --cached --stat
  echo

  if ( read 'choice?$$ View Diff? ' && [[ $choice == (Y|y)* ]] ); then
    # Display difference between head and updated files
    git diff --cached -u --stat
  fi
}

checked-refresh-index() {
  #: checked-refresh-index [TARGET_PATCH]
  #:   `stg refresh --index` but with diff preview and confirmation
  #:

  __assert_stg_enabled "checked-refresh-index"

  TARGET_PATCH=$(stg top)
  if [[ -n $1 ]]; then
    TARGET_PATCH=$1
  fi

  __check-header "$TARGET_PATCH"
  echo

  echo ">> Diff:"
  echo
  git --no-pager diff --cached --stat
  echo

  if ( read 'choice?$$ View Diff? ' && [[ $choice == (Y|y)* ]] ); then
    # Display difference between head and updated files
    git diff --cached -u --stat
  fi

  if ( read 'choice?$$ Confirm? ' && [[ $choice == (Y|y)* ]] ); then
    echo ">> [applying...]"
    ( set -x; stg refresh --index -p $TARGET_PATCH; )
    echo ">> Verifying Git Status:"
    git status -s
  else
    echo ">> [cancelled]"
  fi
}

checked-refresh-update() {
  #: checked-refresh-update
  #:   `stg refresh` but with diff preview and confirmation
  #:

  __assert_stg_enabled "checked-refresh-update"

  local TARGET_PATCH=$(stg top)

  __check-header "$TARGET_PATCH"
  echo

  echo ">> Diff:"
  echo
  git --no-pager diff --stat HEAD -- "$@"
  echo

  if ( read 'choice?$$ View Diff? ' && [[ $choice == (Y|y)* ]] ); then
    # Display difference between head and updated files
    git diff -u --stat HEAD -- "$@"
  fi

  if ( read 'choice?$$ Confirm? ' && [[ $choice == (Y|y)* ]] ); then
    echo ">> [applying...]"
    ( set -x; stg refresh -- "$@" ; )
    echo ">> Verifying Git Status:"
    git status -s
  else
    echo ">> [cancelled]"
  fi
}

push-set() {
  #: push-set [GREP_EXPR]
  #:   interactively apply patches on the stack that match $GREP_EXPR
  #:

  __assert_stg_enabled "push-set"

  local SEARCH_PATTERN=$1

  local ALL="# ALL #"
  local DONE="# DONE #"

  local FILTERED_SERIES=$(stg series -da | grep "^$SEARCH_PATTERN")

  local SELECT
  SELECT=$(set -e -o pipefail;
    ( echo "$ALL" && echo "$FILTERED_SERIES" ) \
      | fzf --multi +s \
          --height="80%" --preview-window="bottom:60%" \
          --preview="git show --oneline --stat \$(stg id \$(echo {} | awk '{print \$2}'))"
  )
  if [[ $? -ne 0 ]]; then
    __die "push-set: aborted"
  fi

  local TOAPPLY_RAW=$FILTERED_SERIES
  if [[ $(echo $SELECT | head -n 1) != $ALL ]]; then
    TOAPPLY_RAW=$SELECT
  fi

  local TOAPPLY=$(
    for PATCH in $TOAPPLY_RAW; do 
      echo "$PATCH" | awk '{print $2}'
    done
  )

  echo ">> APPLYING:"
  echo ">> --------"
  echo "$TOAPPLY"
  echo ">> --------"

  local STG_PUSH_CMD=( stg push --noapply $(echo $TOAPPLY) )
  ( set -x; : "$STG_PUSH_CMD[@]" ) 2>&1

  echo
  if ! ( read -q 'choice?$$ Confirm? ' ); then
    echo
    echo ">> [cancelled]"
    exit 120
  fi


  local APPLIED_COUNT=$(stg series -A --count)
  # Only pop patches if there are patches to pop.
  if [[ $APPLIED_COUNT -ne 0 ]]; then
    echo
    echo ">> [popping all patches...]"
    ( set -x; stg pop -a )

    if [[ $? -ne 0 ]]; then
      echo "Failed to pop patches" >&2
      return $?
    fi
  fi

  echo
  echo ">> [applying...]"

  local STG_PUSH
  STG_PUSH=$(set -e -o pipefail;
    ( set -x; "$STG_PUSH_CMD[@]" )
    echo $DONE
  )
  if [[ $? -ne 0 ]]; then
    return $?
  fi
  if [[ $STG_PUSH != $DONE ]]; then
    return 100
  fi

  echo
  if ( read -q 'choice?$$ Also goto a certain patch? ' ); then
    local SELECT=$(echo $TOAPPLY | fzf --prompt 'goto:')
    if [[ -n $SELECT ]]; then
        echo
        echo ">> [going to $SELECT...]"
        stg goto "$SELECT"
    fi
  fi
}

stack-publish() {
  #: stack-publish <REMOTE> [REMOTE_BRANCH]
  #:   publish the current stack to the remote
  #:

  __assert_stg_enabled "stack-publish"

  if [[ $# -lt 2 ]]; then
    __die "stack-publish: not enough args [REMOTE] [REMOTE_BRANCH]"
  fi

  local REMOTE_NAME="$1"
  local REMOTE_BRANCH="$2"

  local BRANCH_NAME="$(git rev-parse --abbrev-ref HEAD)"

  local BRANCH_REF="refs/heads/$BRANCH_NAME"
  local BRANCH_STG_REF="refs/stacks/$BRANCH_NAME"

  local R_BRANCH_REF="refs/heads/$REMOTE_BRANCH"
  local R_BRANCH_STG_REF="refs/stacks/$REMOTE_BRANCH"

  if ! ( git rev-parse "${BRANCH_STG_REF}" >/dev/null 2>/dev/null ); then
    __die "stack-publish: ${GIT_BRANCH_STG}: does not exist"
  fi

  echo "stack-publish: publishing [${BRANCH_REF}, ${BRANCH_STG_REF}]"

  ( set -x;
    git push "$REMOTE_NAME" \
        "${BRANCH_REF}:${R_BRANCH_REF}" \
        "${BRANCH_STG_REF}:${R_BRANCH_STG_REF}"
  )
}

stack-pull() {
  #: stack-pull [REMOTE] [REMOTE_BRANCH] [LOCAL_BRANCH]
  #:   update the current stack from the remote
  #:

  __assert_stg_enabled "stack-pull"

  if [[ $# -lt 2 ]]; then
    __die "stack-pull: not enough args [REMOTE] [REMOTE_BRANCH] [LOCAL_BRANCH]"
  fi


  local REMOTE_NAME="$1"
  local REMOTE_BRANCH="$2"
  local LOCAL_BRANCH="$3"

  local R_BRANCH_REF="refs/heads/$REMOTE_BRANCH"
  local R_BRANCH_STG_REF="refs/stacks/$REMOTE_BRANCH"

  if [[ -n $LOCAL_BRANCH && $LOCAL_BRANCH != "--fetch" ]]; then
    local BRANCH_REF="refs/heads/$LOCAL_BRANCH"
    local BRANCH_STG_REF="refs/stacks/$LOCAL_BRANCH"

    if ( git rev-parse "${BRANCH_REF}" >/dev/null 2>/dev/null ); then
      __die "stack-pull: ${BRANCH_REF}: already exists please delete"
    fi
    if ( git rev-parse "${BRANCH_STG_REF}" >/dev/null 2>/dev/null ); then
      __die "stack-pull: ${BRANCH_STG_REF}: already exists please delete"
    fi

    echo "stack-pull: pulling [${BRANCH_REF}, ${BRANCH_STG_REF}]"

    ( set -x;
      git fetch "$REMOTE_NAME" \
          "${R_BRANCH_REF}:${BRANCH_REF}" \
          "${R_BRANCH_STG_REF}:${BRANCH_STG_REF}"
    )
  else
    echo "stack-pull: fetching [${BRANCH_REF}, ${BRANCH_STG_REF}]"

    ( set -x;
      git fetch "$REMOTE_NAME" \
          "${R_BRANCH_REF}" \
          "${R_BRANCH_STG_REF}"
    )
  fi
}

patch-publish() {
  #: publish-patch [PREFIX] [REMOTE]
  #:   publish the current patch to the remote
  #:   config:
  #:     - git config stg.utils.publish-ref-prefix "$(whoami)" -- the prefix for published patches
  #:

  __assert_stg_enabled "publish-patch"

  local __PREFIX_CONFIG__="stg.utils.publish-ref-prefix"

  local REMOTE_PREFIX="$1"
  local REMOTE_NAME="$2"

  if [[ $REMOTE_NAME == "" ]]; then
    REMOTE_NAME=$(__git_branch_remote $(__git_current_branch))
  fi
  if [[ $REMOTE_NAME == "" ]]; then
    local DEFAULT_REMOTE=$(__git_remotes | head -n 1)
    if [[ $DEFAULT_REMOTE == "" ]]; then
      __die "publish-patch: no remotes configured"
    fi
    REMOTE_NAME=$DEFAULT_REMOTE
  fi

  if [[ $REMOTE_PREFIX == "" ]]; then
    REMOTE_PREFIX=$(__git_config_get "$__PREFIX_CONFIG__" "")
  fi
  if [[ $REMOTE_PREFIX == "" ]]; then
    __die "publish-patch: please set $__PREFIX_CONFIG__ or provide as second argument"
  fi

  local GIT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
  local STG_TOP=$(stg top 2>/dev/null)

  echo | xargs -p \
    git push "$REMOTE_NAME" "HEAD:refs/heads/$REMOTE_PREFIX/${STG_TOP}"
}

patches-by-file() {
  #: patches-by-file
  #:   for each file modified by the stack show which patches this file is affected by
  #:

  for diff_file in $(git diff "$(stack-top)~1.." --name-only | sort -u); do
    print "$diff_file"
    for patch in $(git run stg patches "$diff_file"); do 
      print "\- $patch"
    done
  done
}

stack-files() {
  #: stack-files
  #:   show all files the patches in the stack modify
  #:

  git diff "$(stack-top)~1.." --name-status | cat
}

series-pretty() {
  #: stg-series-pretty [-f] [-e] [-n] [<stg series options>]
  #:   prints expanded information about the patches in the current stack
  #:
  #:   -n | --notes : show notes associated with git commit
  #:   -e | --extra : show git sha, notes
  #:   -f | --full  : show git sha, notes, commit msg & files affected
  #:

  local ARGS=()

  local _full=0
  local _extra=0
  local _notes=0
  local _help=0
  local _filter_set=0
  while [[ $# -gt 0 ]]; do
    if [[ $1 == (--full|-f) ]]; then
      _full=1
      shift
    elif [[ $1 == (--extra|-e) ]]; then
      _extra=1
      shift
    elif [[ $1 == (--notes|-n) ]]; then
      _notes=1
      shift
    elif [[ $1 == (--help|-h) ]]; then
      _help=1
      shift
    elif [[ $1 == (-a|-A|-U|-H) ]]; then
      _filter_set=1

      ARGS+=($1)
      shift
    else
      ARGS+=($1)
      shift
    fi
  done

  if [[ $_filter_set -eq 0 ]]; then
    ARGS=(-A)
  fi

  if [[ _help -eq 1 ]]; then
    stg series -h
    exit $?
  fi

  while read line; do
    if [[ $line == "" ]]; then
      continue
    fi

    # ZSH-NOTE: ( ${(@f)$( command )} ) splits command output by newline, returns array. (zsh)
    stg_fields=( "${(@f)$(
      echo $line | jq -r '"\(.op)\n\(.patch)\n\(.subject)\n\(.patchCOL)"'
    )}" )

    stg_patch_status=${stg_fields[1]}
    stg_patch_name=${stg_fields[2]}
    stg_patch_description=${stg_fields[3]}
    stg_patch_name_col=${stg_fields[4]}

    git_sha=$(stg id "$stg_patch_name" | xargs git rev-parse --short)

    COLOR=1
    if [[ $stg_patch_status == "+" ]]; then
      COLOR=2
    elif [[ $stg_patch_status == ">" ]]; then
      COLOR=3
    fi

    printf "%s" $(tput setaf $COLOR)
    printf "%s %s" $stg_patch_status $stg_patch_name_col
    printf "%s" $(tput sgr0)
    printf " # %s" $stg_patch_description
    printf "\n"

    details=$(
      if [[ $_full -eq 1 || $_extra -eq 1 ]]; then
        printf "%s" "$(tput setaf 5)"
        printf "git-sha "
        printf "%s" "$(tput setaf 4)"
        printf "%s" $git_sha
        printf "%s" "$(tput sgr0)"
        printf "\n\n"
      fi

      if [[ $_full -eq 1 ]]; then
        git_commit_msg=$(
          git show -s --format=%b "$git_sha" \
            | fold -w 80 -s \
            | perl -0pe 's:[\n\s]+$:\n:'
        )

        commit_prefix="$(tput setaf 1)#$(tput sgr0)"
        if [[ -n $git_commit_msg ]]; then
          echo "$git_commit_msg" \
            | awk -v prefix="$commit_prefix" '{print prefix " " $0}'
        else
          echo "$commit_prefix [ No Commit Summary ]"
        fi
        echo
      fi

      if [[ $_full -eq 1 || $_notes -eq 1 || $_extra -eq 1 ]]; then
        git_notes=$(
          git notes show "$git_sha" 2>/dev/null
        )
        if [[ -n $git_notes ]]; then
          echo "$git_notes" \
            | perl -pe "s:^\\s*([^\s]+)\\s+(.*):$(tput setaf 4)\\1$(tput sgr0) \\2:" \
            | column -tx -s " "
          echo
        fi
      fi

      if [[ $_full -eq 1 ]]; then
        git show --name-status --format= "$git_sha" \
          | perl -pe "s:^(\\s*\\w+)(.*):$(tput setaf 2)\\1$(tput setaf 4)\\2$(tput sgr0):"
      fi
    )

    if [[ -n "$details" ]]; then
      result=$(
          printf "%s" "$details"
          printf "\n \n"
      )
      echo "$result" | sed 's:^:    :'
    fi
  done << EOF
$(__series_json "${ARGS[@]}")
EOF
}


#######################################################################
# Helpers
#######################################################################

tig() {
  command tig $(stg id $(stg series -A --noprefix | head -n1))~2..
}

stack-top() {
  #: stack-top
  #:   get the sha of the last applied commit in the stack
  #:

  __list-patches -A | tail -n 1 | xargs stg id
}

stack-bottom() {
  #: stack-bottom
  #:   get the sha of the first applied commit in the stack
  #:

  __list-patches -A | head -n 1 | xargs stg id
}

#######################################################################
# Internal
#######################################################################

__assert_stg_enabled() {
  # Check that STG is enabled
  ERR=$(stg series --count 2>&1)
  if [[ $? -ne 0 ]]; then
    __die "$1: $ERR" 120
  fi
}

__git_remotes() {
  git remote 2>/dev/null
}

__git_current_branch() {
  git rev-parse --abbrev-ref HEAD 2>/dev/null
}

__git_branch_remote() {
  local GIT_BRANCH=$1
  git config --get branch.$GIT_BRANCH.remote 2>/dev/null
}

__git_config_get() {
  local CONFIG_KEY=$1
  local CONFIG_DEFAULT=$2
  shift 2

  local RESULT
  RESULT=$(git config --get "$CONFIG_KEY" 2>/dev/null)
  if [[ $? -ne 0 ]]; then
    printf "%s" "$CONFIG_DEFAULT"
  fi
  printf "%s" "$RESULT"
}

__stg_enabled() {
  # Check that STG is enabled
  stg series --count 2>/dev/null >/dev/null
}

__list-patches() {
  #; __list-patches [<stg series options>]
  #;   prints undecorated list of patches
  #;

  stg series --noprefix --no-description "$@"
}

__series_json() {
    stg series -d "$@" | jq \
    -c -R '
    .
    | capture("(?<op>(\\+|-))\\s+(?<patchCOL>[^#]+)\\s#\\s+(?<subject>.*)")
    | .patch = ( .patchCOL | gsub("\\s+";"") )
    '
}

#######################################################################


if [[ "$1" == (-h|--help|-?|help) ]]; then
  __help
  exit 125
fi
# ( set -x; "$@" )
"$@"
